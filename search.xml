<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2022/04/24/pai-xu-suan-fa-zong-jie/"/>
      <url>/2022/04/24/pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><h4 id="稳定的排序："><a href="#稳定的排序：" class="headerlink" title="稳定的排序："></a>稳定的排序：</h4><ul><li>冒泡排序</li><li>插入排序</li><li>归并排序</li><li>计数排序</li></ul><blockquote><p>上述基于比较的排序算法在遇到相同的值时不做交换，这样保证了稳定性；</p></blockquote><h4 id="不稳定排序："><a href="#不稳定排序：" class="headerlink" title="不稳定排序："></a>不稳定排序：</h4><ul><li>快速排序</li><li>堆排序</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>如果相邻的两个元素处于错误的顺序，那么交换这两个元素，如此重复。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 外层循环，n - 1次，每次将最大值沉底，下次排序的范围-1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 内层循环，在排序范围内比较相邻的两个元素是否有序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>对元素 $i$ ，在前面的 $i-1$ 个位置中找到它应该插入的位置。向前寻找位置的过程中向后移动元素，腾出空间。插入排序是一种稳定的排序算法。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>当序列顺序完全颠倒时具有最差的时间复杂度 $O(n^2)$</p><p>当序列完全有序时具有最优时间复杂度 $O(n)$ </p></blockquote><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是一种基于比较的排序算法，其底层数据结构为二叉堆。堆排序和选择排序相似，选择排序中我们每次选择最小值放在数组的头部，然后对剩余的元素重复这样的过程。堆排序也是如此，以大顶堆为例，我们每次选择堆顶元素，将其与数组的末尾元素交换，这样最大值就放在了数组的尾部，此时堆结构被破坏，需要重新调整使其满足堆的结构。然后对剩余的前 n - 1 个元素重复这样的过程。</p></blockquote><h4 id="为什么堆使用数组来表示？"><a href="#为什么堆使用数组来表示？" class="headerlink" title="为什么堆使用数组来表示？"></a>为什么堆使用数组来表示？</h4><blockquote><p>因为堆的数据结构是完全二叉树，很容易用数组来表示，并且空间效率很高。如果父节点的下标是 $i$ ，那么它的孩子节点下标分别是 $2<em>i+1$ 和 $2</em>i+2$ 。(下标从0开始)</p></blockquote><h4 id="堆排序的过程："><a href="#堆排序的过程：" class="headerlink" title="堆排序的过程："></a>堆排序的过程：</h4><blockquote><ol><li>根据输入数据建立一个大顶堆；</li><li>建好堆以后，堆顶元素即为最大值。将堆顶元素与数组末尾元素互换，然后将堆的 $size-1$  ，然后调整堆的结构，也就是对堆顶元素进行 $heapify$ ；</li><li>重复 step2 直到堆的 $size &#x3D;&#x3D; 1$ 。</li></ol></blockquote><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 把以下标i为根的子树堆化，n是堆的大小</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">// 初始化largest为根的下标</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 左孩子</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 右孩子</span>        <span class="token comment">//如果左孩子在堆的范围内，并且左孩子比根节点大，更新largest为左孩子的下标</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//如果右孩子在堆的范围内，并且右孩子比根节点大，更新largest为右孩子的下标</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果根节点已经不是最大值，交换根节点与最大值，继续调整</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 建堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从最后一个元素开始与堆顶元素交换，同时i也是当前堆的大小</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h4><blockquote><p>堆排序是一种原地排序算法，空间复杂度为 $O(1)$ 。</p><p>堆排序的经典实现是<strong>不稳定</strong>的，但是也可以有稳定的实现。</p></blockquote><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p> $heapify$ 的时间复杂度为 $O(logn)$ ，建堆和调整堆的大小的过程的时间复杂度为 $O(n)$ ，总体时间复杂度为 $O(nlogn)$ 。</p></blockquote><h3 id="C-优先队列"><a href="#C-优先队列" class="headerlink" title="C++优先队列"></a>C++优先队列</h3><p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</code></p><p>参数列表：</p><ul><li>第一个参数 <code>int</code> ：表示优先队列存储的数据类型；</li><li>第二个参数 <code>vector&lt;int&gt;</code>：表示优先队列的底层使用什么容器来存储数据，一般使用 vector ；</li><li>第三个参数 <code>less&lt;int&gt;</code>：比较类型，less 表示是大顶堆，great 表示是小顶堆；</li></ul><p>自定义数据类型时需要重载运算符 <code>&lt;</code> 或者重写一个比较类型：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> num<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> root<span class="token punctuation">;</span>    <span class="token comment">// 重载运算符：</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Node<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> num <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token comment">// 大顶堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个优先队列，大顶堆</span>priority_queue<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">,</span> less<span class="token operator">&lt;</span>Node<span class="token operator">>></span> q<span class="token punctuation">;</span><span class="token comment">// 重写比较类型</span><span class="token keyword">struct</span> <span class="token class-name">cmp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>num <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token comment">// 大顶堆</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 创建一个优先队列，大顶堆</span>priority_queue<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">,</span> cmp<span class="token operator">></span> q<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2022/04/24/01-bei-bao-wen-ti/"/>
      <url>/2022/04/24/01-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h3><p><img src="https://gitee.com/fduwangjian/imagebed/raw/master/images/2022/202204241125236.png" alt="题目描述"></p><p>乍看毫无思路，但仔细想想，这就是相当于把石头分成两堆，两堆相互碰撞，最后剩下的重量最小。那么就可以转化为<strong>01背包问题</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lastStoneWeightII</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> stones<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> stones<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>stones<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stones<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tgt <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>tgt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// dp[i]表示容量（可容纳的重量）为i的背包最多可以装下重量为dp[i]的石头</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 正序遍历物品</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> tgt<span class="token punctuation">;</span> j <span class="token operator">>=</span> stones<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 倒序遍历背包</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> stones<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> stones<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum <span class="token operator">-</span> dp<span class="token punctuation">[</span>tgt<span class="token punctuation">]</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>tgt<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划, dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
